## 浅谈权限

有几个权限概念要捋一捋

认证(ldentification)授权(Authorization)鉴权(Authentication)权限控制(Access/Permission Control)

**认证**

根据声明者持有的特定信息，来确认声明者的身份
关键点是特定信息，这个信息，一般也称为认证因素。比如最常见的用户名密码，说白了，就是我要用这些信息来证明“我就是我”
更具体的，如何证明“我是我”?

其实就是一个信息比较的过程，一定要预先有一个数据库来储存原信息
比如:

```
我持有我预留在数据库中的密码
我持有的人脸与数据库中我的人脸数据相同
我持有的手机短信验证码与数据库中的验证码相同-->认证我持有该手机-->持有该手机的就是用户本人
我持有某个权威第三方的凭证来证明自己(0auth2认证)
```

例如身份证、用户名/密码、手机(包括短信、二维码、手势密码)、电子邮箱、生物特征(虹膜、面部、指纹、语音等)
高安全要求的场景下，会使用多种认证方式组合进行身份校验，即多因素认证

认证这里，我们要讲一个相对而言比较少见的认证方式

挑战/应答(Challenge/Response)方式的身份认证

**授权**
服务器给予的临时凭证，持有该凭证的用户即认为已经经过了认证，无需再次进行认证。

并且，在授权的过程中，要明确的是权限也是划分等级的。一个管理员账户与一个普通用户账户自然不能比较。
**临时凭证**

```
cookie
session
jwt认证
ak/sk
```

**鉴权**
我们刚才讲到，已经持有凭证的用户，被认为已经经过了认证了，无需再次进行认证。

但是仍然存在一个问题，该凭证是否有安全风险?该凭证是否是伪造的?另外，权限是分等级的，那么凭证自然也有三六九等，这个该如何区分呢?

这就是鉴权的作用，鉴权这个环节做的就是:

```
鉴定用户是否持有授权
鉴定用户的授权是否有效
鉴定用户的授权的等级
```

在比较传统或者常规的情况下，授权与鉴权往往在同一台服务器上(cookie/session/jwt均是如此)，但是jwt认证和ak/sk则可以跳出这个范畴，可以让授权跟鉴权的服务器不在一台上

**认证和鉴权的异同:**

认证确认的是声明者的身份，鉴权则是对声明者声明的权限进行确认
认证需要通过声明者独特的信息进行识别，鉴权则是通过鉴别授权过程中定义的某个媒介，这个媒介具有真实有效、不可篡改、不可伪造等特性

**挑战/应答(Challenge/Response)方式的身份认证**

安全问题的本质是信任问题
不信任任何输入==> 信任输入的检测逻辑
挑战、应答机制就是一种依赖于检测逻辑的机制。
一般是这样一个流程

```php
echo "Hello!challenge here!"//生成挑战码，一般是个随机字符串之类的

code = ChallengeCodeGenerater()//根据挑战码生成应该得到应答

resp = respGenerater(code)

echo "here is the ChallengeCode:" + codeuser_input= read_input() //获取用户应答

if user_input == resp{//检测用户应答是否正确

​	echo "you are in"

}else{

​	echo "out!"

}
```

所以说，这种挑战、应答机制是否安全，强依赖于respGenerater中生成逻辑。一旦其生成逻辑开源出来，并且是一个环境无关的检测逻辑，那么很有可能就被击溃，因为攻击者并不需要考虑任何环境因素。
比如我的检测逻辑是

```php
func respGenerater(code){

	return md5(date()+ code);

}
```

就秒死

有一个强依赖于环境的变量在其中，比如:某设备出厂的时候，就是一机一码的，该唯-的身份码已经直接硬编码写在机器的/etc/qiangqiang目录，每个机器都不一样。只有厂商在自家的数据库有存，这种情况下，我们就没办法直接预知了。

授权方式/身份凭证

cookie验证：

```php
<?php
if($_CO0KIE["user_id"] == 0){
echo"你是管理员";
}else{
echo"你是强强”;
?>
```

很简单的案例。其被抛弃的原因也很容易理解，cookies是客户端访问服务端时可以随意修改内容的，也就是相当于黑客随意随意篡改自己的身份凭证，自然是不符合安全要求的了
但是这种方式虽然少了，却往往以其他方式改个头面出来了。我们常见的水平越权、垂直越权，往往黑客只是修改了url或者post数据中的一个参数，就达到目的，就是这个问题的变种。

**session**
认证成功后后端会生成session id，并且将该session id存在某个地方

然后做以下操作:

```
在认证结束的返回(response)中，进行set-cookie将session_id告知客户端浏览器2.客户端在后续的访问中携带session id进行访问(持有身份凭证)
从某个地方检查该session id的有效性(鉴权)
根据鉴权结果，确定是否有权限进行某动作
```

那么，这里就有两个问题了
**进行set-cookie就有xss的风险**
我们知道xss的危害在于攻击者可以在受害者的浏览器中执行is代码。那么如果此时可以通过js来读取cookie，是不是就相当于窃取了用户的凭证了。

不同的语言、框架，对于session的存储方式都不相同。这个很重要，关乎各种攻击方式能不能用。
php
默认存储在服务端/tmp目录下(文件)
flask
默认存储在用户的cookie中(密钥加密)
java
默认存储在内存中

**session存储于文件**
无法对抗/tmp目录文件读取利用，通过读取文件列表获取用户凭证

**session存储于数据库中**
存在sql注入或者其他可以从数据库中读取信息的方式
**session存储于redis中**
如果有方式可以获取到所有的键名(redis基于key-value来存储数据，，一般存储session时，key为session lD，value为session内容)

**jwt认证**
现在市面上有许多人鼓吹jwt认证，并且有许多人认为jwt可以用来代替session认证。这种观点我不那么赞同。我们来看下，session认证在功能上的问题。
存储于内存的方式，用户量大吃内存(稍微有点扯)
存储于进程内存、文件的方式，不适配于目前常见的负载均衡+微服务架构(合理)容易遭受csrf和xss的攻击(不太成立，jwt一样存在)

这是jwt的介绍：https://zhuanlan.zhihu.com/p/158186278

此时有几点要注意的是:

```
1.认证服务器和应用服务器可以是同一台也可以不是

2.应用服务器不需要存储-个session id之类的东西了
```

那这里有几个问题来了:
**jwt可以解决xss吗**
不可以，jwt认证通过后，获取的token，浏览器一样需要保存的，那么保存在哪里，保存在哪里都会被xss获取到，因为xss获取的是浏览器js的权限。

**jwt可以解决csrf吗**
部分解决，因为jwt认证时，大部分场景是放在header中携带的，这在csrf这种跨域场景下默认是不会携带的。所以此时在evil域中嵌入一个app域的链接，并且app域是jwt认证的，在这种情况下，app域就会认证失败，攻击者就无法利用app域的权限来做恶意操作。
但是这种情况存在一种风险，在大部分情况下jwt由js手动加入到header头中进行携带，但是有些程序员将jwt存放于cookie中进行携带认证，那这种场景下就不能防御csrf

**ak/sk认证**
ak: access key
sk : secret key
搞懂了jwt，要搞懂ak/sk就不困难
具体看这里：https://www.cnblogs.com/xiaomengniu/p/16174330.html
