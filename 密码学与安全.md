## 密码学与安全

哈希
一般翻译做散列，或音译为哈希，是把任意长度的输入通过散列算法变换成固定Hash,长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。
比较常见的算法:
MD5
sha-1
需要强调的是，哈希是不可逆的过程。所有对哈希的破解，无非基于两种方式:

**彩虹表**
**GPU运算**

彩虹表是一种以空间换时间的方式，我们熟知的cmd5.com就是赚彩虹表的钱，即尽可能将常用的字符串进行hash，储存在数据库中，当遇到需要获取原文时，从数据库中获取数据。

GPU运算，往往用来覆盖"特定已知特征的序列"。运用GPU的运算能力，临时计算出特定的原文。是彩虹表的补充。
比如

```
qqqq!@#uah87
qqqq!@#DIU8b
qqqq!@#DI48b
qqqq!@#DI!00
```

这几个字符串，如果hash了，cmd5是解不开的，但是如果我们通过观察特征，发现了前7位都是一样的，那么我们就可以用GPU进行运算，降低了复杂度，就可以跑出来了。
根据我了解的数据，普通的GPU，一秒能跑个5-10亿个序列。CPU当然也能跑，但是性能差很多了。

**私钥加密(对称加密)**
简单讲，加密解密用的密钥是同一个

比较常见的算法：

```
AES
DES
3DES
```

**公钥加密(非对称加密)**
公钥加密(Public-Key Encryption)是一种使用密钥对的密码系统。

通常每对密钥包含一个公钥(Public Key)和一个私钥(PrivateKey)。在公钥加密系统中，明文通过公钥进行加密，私钥进行解密。

公钥加密算法

```
rsa
ecc(椭圆曲线加密)
```

关于rsa算法，可以看这里:   https://blog.csdn.net/heihei2017/article/details/94602180
rsa算法的安全性，来自于数学上的一个猜想:
大整数无法快速进行因数分解
-旦有办法将某个大整数快速分解为两个质数的乘积，那么rsa算法不攻自破了。目前人类破解出最大的rsa密钥是768位。而一般实践中要求rsa的密钥长度为1024或者2048。

对rsa的攻击：



https://www.secpulse.com/archives/147760.html

https://paper.seebug.org/727/

**加密解密的代审应对之策**
我们再复习下，加密解密时用到的几个要素，

```
数据(明文、密文)
加密算法
密钥(包括对称加密和非对称加密)
```

所有的加密算法都逃不出这三个要素!
我们可以看到，其中有哪些对于代码审计是已知的呢?

```
数据(明文、密文)==>我们的输入,可控

加密算法==>代审,已知

密钥(包括对称加密和非对称加密)==>代审，已知
```

在最真实的场景中，最大的限制往往来自于密钥，因为加密函数一般开发者已经写好了放在程序中。而密钥可能是一机一码、可能是临时生成。应对一机一码和临时生成，就要另外找接口看看有没有数据泄露可以获取密钥的地方。

**数字签名**
消息认证码还有另一个问题，就是可抵赖性。因为发送方与接收方的密钥是共享的，那么发送方在发送后完全可以抵赖说不是自己发送的(假设信道不可溯源)，因为它可以说密钥被接收方共享出去了。于是密码学大佬们又想了一种新办法，这就是我们上面提到的非对称加密。

发送方：

```php
text = "qiangqiang"
pri_key, pub_key = generate_key_pair()//生成密钥对
sign = encryption(mac(text),pri_key)//生成消息摘要，然后使用私钥对消息摘要进行加密（签名)
sendMsg(text,sign,pub_key)
//将文本、签名、公钥发送
```

接收方：

```php
text = req.get('text')

rightMac = mac(text)

sign = req.get('sign ')

pub_key = req. get( ' pub_key ' )

reqMac = decryption(sign，pub_key)

if reqMac == rightMac:

​	do_something()
```

此时发送方持有一个只有他自己知道的私钥，并且有一个公开的唯一跟该私钥配对的公钥。因为“该公钥能解密该密文，说明该密文一定来自于该私钥的持有者”

对于代码审计而言，数字签名的用处也不少，特别是对应于升级包校验，数字签名是一种很好的技术。

可以用来验证升级包是否来源于厂商发布，而不是一个“获取了代码的攻击者”

更多想知道的知识看这里：https://www.jianshu.com/p/74f5e7db2d37